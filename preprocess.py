import numpy as np
from matplotlib.mlab import PCA
from instances       import Instance
from copy            import deepcopy
from misc            import meanInst

class Preprocessor:
    '''A preprocessor object is generated by the preprocess() function, so that
    subsequent preprocessing can be performed by calling preprocessWith(), with
    the generated Preprocessor object as the second parameter. This will ensure
    that the mappings applied to the instances preprocessed with
    preprocessWith() are identical to those used to preprocess the instances
    initially preprocessed with preprocess().'''
    def __init__(self, meanInst, scaleInst):
        self.meanInst  = meanInst
        self.scaleInst = scaleInst

def preprocess(insts):
    '''Preprocess a list of Instances, returning a Preprocessor object that can
    be used to preprocess more instances with the same mapping.'''
    demeanedInsts, meanInst = demean(insts)
    scaledInsts, scaleInst = scale(demeanedInsts)
    return scaledInsts, Preprocessor(meanInst, scaleInst)

def pprWith(insts, preproc):
    '''Preprocess a list of instances according to the mapping described by the
    given Preprocessor object.'''
    demeanedInsts = [demeanNewInst(inst, preproc.meanInst) for inst in insts]
    return [scaleNewInst(inst, preproc.scaleInst) for inst in demeanedInsts]

def unppr(inst, preproc):
    '''Re-scale and re-mean an instance, returning an instance in the original
    domain.'''
    cpy = deepcopy(inst)
    for i in range(len(cpy.data)):
        cpy.data[i] = (cpy.data[i] * preproc.scaleInst.data[i]) + \
                preproc.meanInst.data[i]
    for i in range(len(cpy.label)): 
        cpy.label[i] = cpy.label[i] * preproc.scaleInst.label[i] + \
                preproc.meanInst.label[i]
    return cpy

def demean(insts):
    '''Produce a new list of instances from the given ones, that have been
    demeaned. Return a new list, and an Instance object that represents the mean
    values of the data from the original instances, that can be used to demean
    unseen instances, or to recover values in the original domain'''

    meanI = meanInst(insts)

    # Create new instances from the old ones and adjust all values appropriately
    newInsts = deepcopy(insts)
    for inst in newInsts:
        for d in range(len(inst.data)):
            inst.data[d] -= meanI.data[d]
        for l in range(len(inst.label)):
            inst.label[l] -= meanI.label[l]
    
    return newInsts, meanI

def demeanNewInst(inst, means):
    '''Given an unseen Instance and an example mean Instance, return a new
    instance in the same domain as the data that produced the example
    Instance'''
    newInst = deepcopy(inst)
    for feat in range(len(newInst.data)):
        newInst.data[feat] -= means.data[feat]
    for lbl in range(len(newInst.label)):
        newInst.label[lbl] -= means.label[lbl]
    return newInst

def scale(insts):
    '''Produce a list of Instances that are scaled versions of the given
    Instances. Return the new instances and an example Instance that stores the
    scale factors for each dimension of the given instances.'''

    # We record the scale factor for feature and return them in a list, so
    # that we can (a) apply an identical transformation to unseen instances and
    # (b) recover the feature values as they were before scaling
    featScales = []

    for feat in range(len(insts[0].data)):

        # Find the maximum value for this feature, which we will use as our
        # scale factor
        absMax = 0
        for inst in insts:
            if abs(inst.data[feat]) > absMax:
                absMax = abs(inst.data[feat])

        # Record this scale factor
        featScales.append(absMax)

    labelScales = []    

    for lbl in range(len(insts[0].label)):

        # Find the maximum value for this target dimension, which we will use as
        # our scale factor
        absMax = 0
        for inst in insts:
            if abs(inst.label[lbl]) > absMax:
                absMax = abs(inst.label[lbl])

        # Record this scale factor
        labelScales.append(absMax)

    # Create new instances from the old ones and adjust all values appropriately
    newInsts = deepcopy(insts)
    for inst in newInsts:
        for d in range(len(inst.data)):
            inst.data[d] /= featScales[d]
        for l in range(len(inst.label)):
            inst.label[l] /= labelScales[l]

    return newInsts, Instance(featScales, labelScales)

def scaleNewInst(inst, scaleFacs):
    '''Given an instance and a scale factor example Instance, for data returned
    by scale(), return a new instance that is equivalent to the given instance,
    but in the scaled domain.'''
    newInst = deepcopy(inst)
    for feat in range(len(newInst.data)):
        newInst.data[feat] /= scaleFacs.data[feat]
    for lbl in range(len(newInst.label)):
        newInst.label[lbl] /= scaleFacs.label[lbl]
    return newInst

class PCAPreprocessor:
    '''The PCAPreprocessor class functions in much the same way as the
    Preprocessor class, except that it performs PCA as well as normalisation.'''

    def __init__(self, pcaObj, preproc):
        '''Create a new PCAPreprocessor object, which stores the object returned
        by a call to matplotlib.mlab.PCA, and the Preprocessor object used to
        normalise the label of the preprocessed instances.'''
        self.pcaObj = pcaObj
        self.preproc = preproc

def pcaPreprocess(insts):
    '''Preprocess some instances using PCA and normalisation. Return the
    transformed data and an object that can be used to perform the same
    transformation on other unseen instances.'''

    # Normalise the instances
    normInsts, preproc = preprocess(insts)

    # Perform PCA on the feature information of the given instances
    pcaObj = PCA(np.array(deepcopy([inst.data for inst in normInsts])))

    # Replace the old feature data with the PCA'd feature data
    pcaInsts = deepcopy([Instance(pcaData, inst.label)
            for pcaData, inst in zip(pcaObj.Y.tolist(), normInsts)])

    return pcaInsts, PCAPreprocessor(pcaObj, preproc)

def pcaPprWith(insts, pcaPreproc):

    # Normalise
    normInsts = pprWith(insts, pcaPreproc.preproc)

    # Project the new feature data into the PCA axis
    pcaData = map(pcaPreproc.pcaObj.project, [i.data for i in normInsts])

    # Replace the old feature data with the PCA'd feature data
    pcaInsts = deepcopy([Instance(pcaD, inst.label)
            for pcaD, inst in zip(pcaData, normInsts)])

    # Return normalised PCA'd data
    return pcaInsts
